<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            margin-bottom: 20px;
        }

        #controls {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .control-group label {
            font-size: 12px;
            color: #ccc;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            background: #333;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: transparent;
        }

        input[type="range"] {
            width: 100px;
        }

        button:hover {
            background: #555;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #canvas {
            border: 1px solid #333;
            background: #111;
            max-width: 100%;
            height: auto;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 24px;
                text-align: center;
            }
            
            #controls {
                gap: 10px;
            }
            
            .control-group {
                gap: 3px;
            }
            
            .control-group label {
                font-size: 11px;
            }
            
            button {
                padding: 8px 16px;
                font-size: 14px;
            }
            
            input[type="color"] {
                width: 35px;
                height: 35px;
            }
            
            input[type="range"] {
                width: 80px;
            }
            
            #canvas {
                width: 100%;
                height: 300px;
            }
        }

        #status {
            margin-top: 10px;
            font-size: 14px;
            color: #888;
        }
    </style>
</head>
<body>
    <h1>Audio Visualizer</h1>
    
    <div id="controls">
        <div class="control-group">
            <button id="startBtn">Start Listening</button>
        </div>
        <div class="control-group">
            <button id="stopBtn" disabled>Stop</button>
        </div>
        <div class="control-group">
            <button id="fullscreenBtn">Fullscreen</button>
        </div>
        <div class="control-group">
            <label>Low Freq Color</label>
            <input type="color" id="lowColor" value="#ff0000">
        </div>
        <div class="control-group">
            <label>Mid Freq Color</label>
            <input type="color" id="midColor" value="#00ff00">
        </div>
        <div class="control-group">
            <label>High Freq Color</label>
            <input type="color" id="highColor" value="#0066ff">
        </div>
        <div class="control-group">
            <label>Brightness</label>
            <input type="range" id="brightness" min="0.1" max="2" step="0.1" value="1">
        </div>
    </div>
    
    <canvas id="canvas" width="800" height="400"></canvas>
    
    <div id="status">Click "Start Listening" to begin audio visualization</div>

    <script>
        class AudioVisualizer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.fullscreenBtn = document.getElementById('fullscreenBtn');
                this.status = document.getElementById('status');
                this.lowColor = document.getElementById('lowColor');
                this.midColor = document.getElementById('midColor');
                this.highColor = document.getElementById('highColor');
                this.brightness = document.getElementById('brightness');
                
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.dataArray = null;
                this.bufferLength = null;
                this.animationId = null;
                this.barHeights = [];
                this.wakeLock = null;
                
                this.setupEventListeners();
                this.setupCanvas();
            }

            setupEventListeners() {
                this.startBtn.addEventListener('click', () => this.start());
                this.stopBtn.addEventListener('click', () => this.stop());
                this.fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
                window.addEventListener('resize', () => this.setupCanvas());
                
                // Handle visibility change to re-acquire wake lock if needed
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible' && this.animationId && !this.wakeLock) {
                        this.requestWakeLock();
                    }
                });

                // Handle fullscreen changes
                document.addEventListener('fullscreenchange', () => this.onFullscreenChange());
                document.addEventListener('webkitfullscreenchange', () => this.onFullscreenChange());
                document.addEventListener('mozfullscreenchange', () => this.onFullscreenChange());
                document.addEventListener('MSFullscreenChange', () => this.onFullscreenChange());
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }

            interpolateColor(color1, color2, factor) {
                return {
                    r: Math.round(color1.r + factor * (color2.r - color1.r)),
                    g: Math.round(color1.g + factor * (color2.g - color1.g)),
                    b: Math.round(color1.b + factor * (color2.b - color1.b))
                };
            }

            async requestWakeLock() {
                try {
                    if ('wakeLock' in navigator) {
                        this.wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Screen wake lock acquired');
                        
                        this.wakeLock.addEventListener('release', () => {
                            console.log('Screen wake lock released');
                            this.wakeLock = null;
                        });
                    }
                } catch (error) {
                    console.warn('Could not acquire screen wake lock:', error);
                }
            }

            releaseWakeLock() {
                if (this.wakeLock) {
                    this.wakeLock.release();
                    this.wakeLock = null;
                }
            }

            toggleFullscreen() {
                if (!document.fullscreenElement && 
                    !document.webkitFullscreenElement && 
                    !document.mozFullScreenElement && 
                    !document.msFullscreenElement) {
                    // Enter fullscreen
                    const element = document.documentElement;
                    if (element.requestFullscreen) {
                        element.requestFullscreen();
                    } else if (element.webkitRequestFullscreen) {
                        element.webkitRequestFullscreen();
                    } else if (element.mozRequestFullScreen) {
                        element.mozRequestFullScreen();
                    } else if (element.msRequestFullscreen) {
                        element.msRequestFullscreen();
                    }
                } else {
                    // Exit fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                }
            }

            onFullscreenChange() {
                const isFullscreen = !!(document.fullscreenElement || 
                                      document.webkitFullscreenElement || 
                                      document.mozFullScreenElement || 
                                      document.msFullscreenElement);
                
                this.fullscreenBtn.textContent = isFullscreen ? 'Exit Fullscreen' : 'Fullscreen';
                
                // Resize canvas when entering/exiting fullscreen
                setTimeout(() => this.setupCanvas(), 100);
            }

            async start() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    
                    this.analyser.fftSize = 512;
                    this.analyser.smoothingTimeConstant = 0.3;
                    
                    this.audioContext.addEventListener('statechange', () => {
                        if (this.audioContext.state === 'suspended') {
                            this.audioContext.resume();
                        }
                    });
                    this.analyser.minDecibels = -90;
                    this.analyser.maxDecibels = -10;
                    this.bufferLength = this.analyser.frequencyBinCount;
                    this.dataArray = new Uint8Array(this.bufferLength);
                    
                    this.microphone.connect(this.analyser);
                    
                    this.startBtn.disabled = true;
                    this.stopBtn.disabled = false;
                    this.status.textContent = 'Listening to microphone...';
                    
                    // Request wake lock to keep screen awake
                    await this.requestWakeLock();
                    
                    this.draw();
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    this.status.textContent = 'Error: Could not access microphone';
                }
            }

            stop() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                if (this.audioContext && this.audioContext.state !== 'closed') {
                    this.audioContext.close();
                    this.audioContext = null;
                }
                
                // Release wake lock when stopping
                this.releaseWakeLock();
                
                this.startBtn.disabled = false;
                this.stopBtn.disabled = true;
                this.status.textContent = 'Stopped';
                
                this.barHeights = [];
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            draw() {
                if (!this.analyser || !this.dataArray) {
                    return;
                }
                
                this.animationId = requestAnimationFrame(() => this.draw());
                
                try {
                    this.analyser.getByteFrequencyData(this.dataArray);
                } catch (error) {
                    console.warn('Audio analysis error:', error);
                    return;
                }
                
                this.ctx.fillStyle = '#111';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                const barWidth = (this.canvas.width / this.bufferLength) * 2.5;
                let barHeight;
                let x = 0;
                
                if (this.barHeights.length === 0) {
                    this.barHeights = new Array(this.bufferLength).fill(0);
                }
                
                // Get current color values
                const lowRgb = this.hexToRgb(this.lowColor.value);
                const midRgb = this.hexToRgb(this.midColor.value);
                const highRgb = this.hexToRgb(this.highColor.value);
                const brightnessValue = parseFloat(this.brightness.value);

                for (let i = 0; i < this.bufferLength; i++) {
                    let value = this.dataArray[i];
                    
                    value = Math.pow(value / 255, 0.7) * 255;
                    let targetHeight = (value / 255) * this.canvas.height * 1.5;
                    
                    // Always use current audio data, but add decay effect for visual smoothness
                    if (targetHeight > 1) {
                        // There's audio input - use it directly
                        this.barHeights[i] = targetHeight;
                    } else {
                        // No significant audio - decay the bar
                        this.barHeights[i] *= 0.88;
                        if (this.barHeights[i] < 1) {
                            this.barHeights[i] = 0;
                        }
                    }
                    
                    barHeight = this.barHeights[i];
                    
                    // Calculate color based on frequency position and amplitude
                    const freqPosition = i / this.bufferLength;
                    const amplitudeIntensity = Math.min(1, barHeight / this.canvas.height);
                    
                    let color;
                    if (freqPosition < 0.33) {
                        // Low frequencies - blend between low and mid colors
                        const factor = freqPosition / 0.33;
                        color = this.interpolateColor(lowRgb, midRgb, factor);
                    } else if (freqPosition < 0.66) {
                        // Mid frequencies - blend between mid and high colors
                        const factor = (freqPosition - 0.33) / 0.33;
                        color = this.interpolateColor(midRgb, highRgb, factor);
                    } else {
                        // High frequencies - use high color with intensity variation
                        color = { ...highRgb };
                    }
                    
                    // Apply brightness and amplitude intensity
                    const r = Math.min(255, color.r * brightnessValue * (0.3 + 0.7 * amplitudeIntensity));
                    const g = Math.min(255, color.g * brightnessValue * (0.3 + 0.7 * amplitudeIntensity));
                    const b = Math.min(255, color.b * brightnessValue * (0.3 + 0.7 * amplitudeIntensity));
                    
                    this.ctx.fillStyle = `rgb(${r},${g},${b})`;
                    this.ctx.fillRect(x, this.canvas.height - barHeight, barWidth, barHeight);
                    
                    x += barWidth + 1;
                }
            }
        }

        const visualizer = new AudioVisualizer();
    </script>
</body>
</html>